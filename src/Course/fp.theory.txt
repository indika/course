* Function Theory



An expression expr is referentially transparent if in all programs p,
all occurrences of expr in p can b ereplaced by the result assigned
to


something about substituitions, with no effect

p = {
    result = expr
    result = expr
    f(expr, expr)
}


has the program changed? if so, then it is not referentially transparent.



* Left association
    [ Function application is left associative]


* Right associative

    Int -> (Int -> Int)
    a function that takes an Int,
        and returns a function
        that takes an Int and returns an Int


\y
    this is an anoymous function



all functions in haskell take one parameter



* Subtraction versus Negative



* Higher Order Functions



    can pass functions as values

    orange (\n -> n + 6)

    orange (\n m -> n + m)
    :t (\n m -> n + m)





* Shapes

    data Shape = Box Int
    data Shape = Box Int deriving (Show, Eq)

    it looks like Shape is the thing that is constructed

    Box is what we call it,
        but I think that Shape is a predefined constructor

    it has a constructor has Box,


    sometimes the type constructor and the data constructor can have the same name
        like:
        data Shape = Shape Int deriving (Show, Eq)


    doesn't want boxes anymore,
        so change things to a Rect

        data Shape = Rectangle Int Int deriving (Show, Eq)



    it appears as though Shape is not a value,
    but it is a Type

    but Rectangle, does have a type:
        *Main> :t Rectangle
        Rectangle :: Int -> Int -> Shape



    * Now, we are having different types of Shapes,

    data Shape = Rectangle Int Int | Circle Int deriving (Show, Eq)

        we can make this look a little bit more pretty:

        data Shape =
            Rectangle Int Int
            | Circle Int
            deriving (Show, Eq)



    so now I can do things like this:
        Rectangle 4 6
        *Main> Circle 3
        Circle 3



    * And now for some pattern matching

        area :: Shape -> Int
        area (Rectangle w h) = w * h
        area (Circle r) = r * 2 * 3


        * And this is how I call it:
            area (Rectangel 5 3)




* Some stuff that does not really work for me


data Person =
    Person {
        name :: String
        age :: Int
    } deriving (Eq, Show)


indika = Person "indika" 30

p { name = 'mark', age = 100}





* Understanding the Data Type

    it is apparently a recursive data type

    4 :. 5 :. Nil
    this returns a List
    [4, 5]




* headOr

headOr h Nil =  h


    * What is headOr about?


    So we are definiting a function
    The function has a type signature
    And it does some pattern matching

    What is the intension of the function?
        it takes a value,
        it takes a list

        and returns the value if the list is empty


    headOr :: a -> List a -> a
    headOr h Nil = h



* product

    What is product about?

    We are defining a function
    That takes a List of Int, and returns an Int

    What is it supposed to do,
    take the product of the items in the list





* Definition of a List

    we are defining a list here

    data List t =
      Nil
      | t :. List t
      deriving (Eq, Ord)

    it is either Nil,
    or an item, and itself

    this is a recursive definition of a list


    * There was something about downcasting


    * something about has a type, and is a type
        Int is a Type
        7 Has a Type

        List is a Type
        :t is type of
            so it does not make sense to do,
            :t List


data List t =
  Nil
  | t :. List t
  deriving (Eq, Ord)

data List t = Nil | RCons t (List t) deriving (Eq, Ord)

* If I use a proper name,
    it has to be in prefix

* Parenthesis around List
    because it becomes ambigious



>> :t (:.)
(:.) :: t -> List t -> List t

>> :t (:.) "bob"
(:.) "bob" :: IsString t => List t -> List t

>> :t (:.) 5
(:.) 5 :: Num t => List t -> List t

>> :t (:.)
(:.) :: t -> List t -> List t

>> :t (:.) 5
(:.) 5 :: Num t => List t -> List t

>> :t (:.) (5::Int)
(:.) (5::Int) :: List Int -> List Int

>> :t (:.) (5::Int) Nil
(:.) (5::Int) Nil :: List Int

>> (:.) (5::Int) Nil
[5]

>> :t (:.) (5::Int) ((:.) 7 Nil  )
(:.) (5::Int) ((:.) 7 Nil  ) :: List Int

>> (:.) (5::Int) ((:.) 7 Nil  )
[5,7]


data MyList t =
  Nil
  | RCons t (MyList t)
  deriving (Eq, Ord)

  :t Rcons is
  -- RCons :: t -> MyList t -> MyList t

  because RCons  returns a data type MyList t






